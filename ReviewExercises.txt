#########################################################################
# Use this file to answer Review Exercises from the Big Java textbook
#########################################################################

R13.1 Terms
a. Recursion - a computation technique that solves a problem by using the solution to the same problem with simpler
               inputs.  a method that calls itself to solve a problem.

b. Iteration - a computation technique that solves a problem by using a counter whereby some code is repeated.  a method
               that counts that solve a problem.

c. Infinite recursion - when a block of (recursive) code repeats itself endlessly because the arguments do not get
                        simpler or because a special terminating case is missing.

d. Recursive helper method - a method that solves a similar (slightly easier) problem that can then be applied to
                             solve the original (more complex) problem with recursion.


R13.2 Smallest value
// pseudocode
// define method signature: minValue(int[] numbers, int startingIndex)
// define size of numbers array (iSize)
// define the min value as numbers[startingIndex] (iMin)
// if startingIndex == iSize - 1, then return iMin -> at end of array, so return last value
// return the smaller of the value at current index (iMin) or
        // min of remaining numbers (minValue(numbers, startingIndex + 1))

Code implemented below:

    public static int minValue(int[] numbers, int index) {

        int iSize = numbers.length;
        int iMin = numbers[index];

        if (index  == iSize - 1)
            return iMin;

        if (numbers[index] < minValue(numbers, index + 1))
            iMin = numbers[index];
        else
            iMin = minValue(numbers, index + 1);
        return iMin;
    }


R13.3 Sort array of numbers
// pseudocode
// define method signature: sort(int[] numbers, int index)
// define the size of the array (iSize)
// if index == iSize - 1, then return the array numbers -> at end of array
// define the min value in the array, from index forward (iMin)
// if iMin < value at index (numbers[index]), then swap values
// return the sort (numbers, index + 1)

Code implemented below:

    public static int[] sort(int[] numbers, int index) {
        int iSize = numbers.length;
        if (index == iSize - 1)
            return numbers;
        int iMin = minValue(numbers, index);

        if (iMin < numbers[index]) {
            numbers[index(iMin, numbers, index)] = numbers[index];
            numbers[index] = iMin;
        }

        return sort(numbers, index + 1);
    }

    public static int index(int value, int[] numbers, int startingIndex) {
        if (startingIndex == numbers.length)
            return -1;
        if (numbers[startingIndex] == value)
            return startingIndex;
        else return index(value, numbers, startingIndex + 1);
    }


R13.6 Exponents recursively
public static int exp(int x, int n) {
    if (n < 0)
        throw new IllegalArgumentException("n cannot be negative");
    if (n == 0)
        return 1;
    return x * exp(x, n - 1);
}


R13.8 Factorial recursively
public static int factorial(int n) {
    if (n < 0)
        throw new IllegalArgumentException("n cannot be negative");
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}